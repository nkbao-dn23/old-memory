- File này dùng để than thở là chính, có kèm theo quá trình làm 
- Haizz, cuối cùng cũng xong bài này, vã vl ra.
- Bài này nói chung là mới vào nhìn nhận đó là bài ELF-32bit static, không canary, có NX, bị lỗi overflow (+ close(0/1/2))
- Thật ra hơn 1 năm trước gặp bài này rồi mà hồi đó chưa đủ trình nên không biết làm, lần này gặp lại lại bị nỗi sợ hồi trước đè nén nên cũng dành thời gian đọc lại writeup trước kia thật kĩ. Lúc làm xong mới thấy những cái mình đọc chỉ chiếm 1/10 cơ hội giải được bài này, 9 phần còn lại chính là thời gian viết shellcode, tìm hướng đi sml.
- Cụ thể, cái overflow này cho phép mình thực thi hàm _dl_make_stack_executable, sau khi gọi được hàm này + set tham số phù hợp thì stack sẽ có quyền thực thi, khi đó đoạn payload phía sau sẽ là shellcode, thoải sức cho mình chơi. Đấy cái phần đơn giản thế thôi mà tưởng khó, làm cứ sợ ngày này qua ngày khác trong khi cái khó thật sự đang ở phía sau.
- Lúc này mình mới viết cái shellcode (open, read, socket, connetct, write), socket là để connect đến vps, nhờ vào cái socket ấy để thèn write có sock_fd để gởi flag qua vps cho mình. Khi đấy mình chỉ cần mở 1 cổng với dịch vụ lưu toàn bộ dữ liệu được đưa vào cổng đó thôi, cơ  mà cái vụ mà syscall 32bit của thèn socket, connect không đơn giản như mấy syscall khác đâu nha (từ khóa nè connect back shellcode)
- Viết xong cái shellcode này chợt nhận ra payload = rop + shellcode <= 100 cơ mà nó > 100 cmnr, thế là phải nghĩ cách khác.
- Sau 1 hồi thì nghĩ được cách đó là sử dụng vps để gởi thêm dữ liệu, nghĩa là payload2 (payload1 là rop) chỉ gồm socket, connect, read(stack), rồi trên vps đặt 1 dịch vụ mới để khi được socket của payload2 gởi đến thì nó sẽ gởi đi shellcode: open, read, socket, connect, write vào stack rồi thực thi tiếp. CƠ mà có điều không may: cái payload mà thèn vps gởi đi vô tình overwrite được cái payload2, nên cái payload2 chưa thực thi xong đã bị overwrite mất rồi.
- Sau 1 hồi tìm cách để ghi vào được stack nhưng bế tắc, vì lúc này chỉ có stack mới có quyền thực thi. Thì phát hiện cách làm cho vùng nhớ khác cũng có quyền thực thi đó là nhờ vào hàm mprotect. Cơ mà thèn payload2 chỉ đủ cho (socket, connect, read) thôi nên muốn set .bss execute phải thực thực hiện trong stack, nghĩa là sẽ cần 3 shellcode:
	+ shellcode1 (payload2): socket, connect, read (chuyển qua shellcode2)
	+ shellcode2: mprotect, read(bss) (xong rồi chuyển qua shellcode3)
	+ ở đây chợt nhận mở 2 cổng (1 cổng nhận flag, 1 cổng gởi shellcode 2 và 3) chi bằng để luôn 1 cổng, khỏi phải gọi socket, connect 2 lần, cùng với đó sockfd = 0 cmnr nên cũng không cần đắn đo nhiều. vậy là thèn shell này chỉ cần open, read, write
- Tưởng thế là xong, đến đây mới cay, tđn lại đọc méo được file /home/kidding/flag, chuyển qua đọc file kidding thì ok, chuyển qua đọc file run.sh thì không được. Tới đây bắt đầu hãm, méo biết chuyện gì xảy ra, vì theo thường lệ read sẽ đọc hết số byte, cơ mà đây nó méo đọc được byte nào ở 2 file flag và run.sh, nên chuyển qua read kiểu khác, đó là read 1 byte, read cho đến khi nào không read được nữa thì lúc đó mới in ra (lúc read để trong vòng lặp có inc số lượng kí tự read được). Và rồi file run.sh đã hiện ra... Nhưng tđn file flag lại tiếp tục đọc không được byte nào. Đến lúc này có cảm giác như thèn pwnable.tw troll mình nhưng méo biết làm sao để check file flag nó định dạng ra sao (flag, flag.txt, FLAG, ...) Nghĩ đến đây mà cay.
- Bắt đầu vọc nào là open, openat, getdents, ... các kiểu nhưng vẫn no_hope.
- Thật ra ngay từ đầu mình đã nghĩ thấy thèn shellcode3 để mở shell rồi nhưng dell biết interactive với thèn server từ đâu, nếu từ vps thông qua sock_fd thì interactive() kiểu gì nên cũng chịu luôn.
- Rồi nhờ sự không bỏ cuộc mình phát hiện ra 1 điều mới: execve có thể leak được thông tin cho mình nhưng không phải đơn giản thế đâu nhé, cái tham số của nó khá khó chịu. Nếu như execve("/bin/sh") ấy thì ecx và edx auto bằng 0 thì dễ rồi, nhưng muốn execve("/bin/ls") thì phải gán thêm pointer trỏ đến 1 mảng pointer (cái này debug sẽ thấy ngay). Thế là sau 1 hồi không biết cách gán cho ecx, nhưng debug cũng được thì mình đã biết được execve("/bin/ls", {"/bin/ls", "/home/kidding", 0}, 0) và phát hiện ra thèn flag không nằm trong folder kidding, cứ sử dụng execve như thế thì mình phát hiện ra thư mục flag nằm cùng thư mục kidding, trong flag có 3 file. Lại gặp challenge mới: 1 file chứ flag với permission, 1 file source, và 1 file ELF. Sử dụng cách execve để thực thi file /bin/cat (hoặc cách đọc liên tiếp byte từ 1 file với loop read) thì mình đã đọc được file source và biết cách đọc được file flag.
- Thế là bắt đầu thêm vào file vps.c để nó gởi thêm 1 dòng nữa (là cái input để cat được flag) rồi edit cái shellcode 3 thành cho mở hết 3 fd luôn (0/1/2 nhưng thật chất vẫn là cái 0 đầu tiên, dup2(0,x) mà) và execve(./home/flag/get_flag). Nhưng tới đây lại fail tiếp các bạn ạ, méo hiểu sao nó không thể đọc file, tới đây mình chỉ có thể nghĩ là do permission.
- Rồi 1 bầu trời tối lại, thì ra ý định của tác giả là muốn mình lấy shell để đọc file chứ không phải là đọc file bằng shellcode. Nhưng đ* muốn lấy shell nhưng lấy bằng cách nào, biết nó là ở thèn vps rồi nhưng mà thèn ở vps là listen (ncat -nc ./vps -kl 11111) nên nó méo interactive như thèn pwn python được. 
- Rồi tới đây 1 bức tiến khổng lồ, phát hiện ra thèn listen(port) và có thể interactive. Và thế là dễ dàng lấy được shell chỉ cần edit lại cái shellcode3 để nó thực thi /bin/sh, thèn version2.py sẽ lắng nghe gởi shellcode 2 và 3 rồi interactive là xong.
- Ôi cái cách mà nó xong thật là vl, thư viện pwntools mạnh vc, trong khi trước đó mình ngồi viết shellcode để leak từng thông tin một cách sml, thì nó có luôn cái listen(port) ~ remote(ip, port) , ** nó cay.
- Nhưng thôi kệ nhờ vậy mà có cơ hội viết được nhiều shellcode (loop_read, execve_ecx, open, ...)
- Nói chung dù sao cũng qua, có điều viết code nhiều quá, shellcode cũng nhiều nữa nên ngại sắp xếp và edit vl, vậy nên cứ đẩy hết mọi thứ lên đây, sau này vào đọc có gì không hiểu thì vào file readme này vậy :v





